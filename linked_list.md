# Списки

* Список - тип данных, который представляет собой набор элементов, заданных в определенном порядке. 

## Набор операций над списком:

- ПоложитьВКонец(элемент)
- ПолучитьЭлемент(номер)
- ПоложитьВНачало(Элемент)
- УдалитьЭлемент(номер)
- УдалитьЭлемент(элемент)
- ЕстьЛи(элемент)
- Найти(элемент)

## Реализации списков

### Массив

* Поскольку элементы массива расположны в памяти друг за другом, доступ к этим элементам осуществляется очень быстро.

```
int a[] = {3, 4, 5, 6, 7};

[3][4][5][6][7]
 0  1  2  3  4

cout << a[2]; // что происходит?

// значение(адрес(a) + 2 * размер(int))
// а - адрес первого элемнта массива 
```

* Недостатки массива - поскольку массив занимает память блоком, его невозможно расширить, потому что можем задеть чужие данные.

Следовательно, вставка в конец, начало, в середину, переполнение массива - сложные для него ситуации, требующие сдвигов или создания нового массива.

### Связный список

* Связный список состоит из узлов.

Каждый узел хранит значение элемента и ссылку на следующий узел.

Такая организация элементов позволяет избежать затрат на увеличение массива и на сдвиги.

* Недостатки - нельзя получить быстро элемент по индексу.

```
[5] -> [6] -> [7] -> [8]
```
* Добавление в начало:

```
// создали узел
[6] -> NULL
[5] -> [6] -> [7] -> [8]
// перекинули ссылку с нового узла на первый узел исходного списка
[6] -> [5] -> [6] -> [7] -> [8]
```

* Как хранить связный список? - достаточно иметь первый элемент.

```C
#include <iostream>
using namespace std;
// узел
struct Node {
    // значение узла
    int value;
    // указатель на следующий элемент
    // next - переменная, которая
    // содержит адрес другой переменной
    //имеющей тип Node
    Node *next;
};

int main() {
    // объявили 4 узла
    // каждый из узлов хранит
    // какое-либо значение и
    // ссылку на следующий элемент
    Node a;
    Node b;
    Node c;
    Node d;
    // в каждый узел кладем
    // значение
    a.value = 5;
    b.value = 6;
    c.value = 7;
    d.value = 8;
    // &b - взятие адреса какой-либо
    // переменной и положили этот адрес
    // в другую переменную
    // таким образом каждый узел
    // может ссылаться на другой узел
    a.next = &b;
    b.next = &c;
    c.next = &d;
    d.next = NULL;
    // заводим дополнительный
    // узел бегунок
    Node current = a;
    // пока после текущего есть следующий
    while (current.next != NULL) {
        // печатаем значение узла
        cout << current.value << " ";
        // перекидываем наш узел дальше
        current = *(current.next);
    }
    cout << current.value;
    return 0;
}
```